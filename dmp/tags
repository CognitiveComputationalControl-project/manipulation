!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
D	script/sample.py	/^    D = 2.0 * np.sqrt(K)      $/;"	v
DMP_H_	include/dmp/dmp.h	42;"	d
FOURIER_APPROX_H_	include/dmp/fourier_approx.h	42;"	d
FUNCTION_APPROX_H_	include/dmp/function_approx.h	42;"	d
FourierApprox	include/dmp/fourier_approx.h	/^class FourierApprox : public FunctionApprox{$/;"	c	namespace:dmp
FourierApprox	src/fourier_approx.cpp	/^FourierApprox::FourierApprox(const vector<double> &w)$/;"	f	class:dmp::FourierApprox
FourierApprox	src/fourier_approx.cpp	/^FourierApprox::FourierApprox(int order)$/;"	f	class:dmp::FourierApprox
FunctionApprox	include/dmp/function_approx.h	/^	FunctionApprox(){};$/;"	f	class:dmp::FunctionApprox
FunctionApprox	include/dmp/function_approx.h	/^class FunctionApprox {$/;"	c	namespace:dmp
K	script/sample.py	/^    K = 100                 $/;"	v
LINEAR_APPROX_H_	include/dmp/linear_approx.h	42;"	d
LinearApprox	include/dmp/linear_approx.h	/^class LinearApprox : public FunctionApprox{$/;"	c	namespace:dmp
LinearApprox	src/linear_approx.cpp	/^LinearApprox::LinearApprox()$/;"	f	class:dmp::LinearApprox
LinearApprox	src/linear_approx.cpp	/^LinearApprox::LinearApprox(std::vector<double> X, std::vector<double> Y)$/;"	f	class:dmp::LinearApprox
MAX_PLAN_LENGTH	src/dmp.cpp	47;"	d	file:
PI	include/dmp/fourier_approx.h	/^const double PI = 3.14159265359;$/;"	m	namespace:dmp
RADIAL_APPROX_H_	include/dmp/radial_approx.h	42;"	d
RadialApprox	include/dmp/radial_approx.h	/^class RadialApprox : public FunctionApprox{$/;"	c	namespace:dmp
RadialApprox	src/radial_approx.cpp	/^RadialApprox::RadialApprox(const vector<double> &w, double base_width, double alpha)$/;"	f	class:dmp::RadialApprox
RadialApprox	src/radial_approx.cpp	/^RadialApprox::RadialApprox(int num_bases, double base_width, double alpha)$/;"	f	class:dmp::RadialApprox
activeCallback	nodes/dmp_server.cpp	/^bool activeCallback(SetActiveDMP::Request &req,$/;"	f
alpha	src/dmp.cpp	/^double alpha = -log(0.01); \/\/Ensures 99% phase convergence at t=tau$/;"	m	namespace:dmp	file:
calcFeatures	src/fourier_approx.cpp	/^void FourierApprox::calcFeatures(double x)$/;"	f	class:dmp::FourierApprox
calcFeatures	src/radial_approx.cpp	/^void RadialApprox::calcFeatures(double x)$/;"	f	class:dmp::RadialApprox
calcPhase	src/dmp.cpp	/^double calcPhase(double curr_time, double tau)$/;"	f	namespace:dmp
centers	include/dmp/radial_approx.h	/^	double *centers;   \/\/Centers of RBFs$/;"	m	class:dmp::RadialApprox
dims	script/sample.py	/^    dims = 2                $/;"	v
dmp	include/dmp/dmp.h	/^namespace dmp{$/;"	n
dmp	include/dmp/fourier_approx.h	/^namespace dmp{$/;"	n
dmp	include/dmp/function_approx.h	/^namespace dmp{$/;"	n
dmp	include/dmp/linear_approx.h	/^namespace dmp{$/;"	n
dmp	include/dmp/radial_approx.h	/^namespace dmp{$/;"	n
dmp	src/dmp.cpp	/^namespace dmp{$/;"	n	file:
dmp	src/fourier_approx.cpp	/^namespace dmp{$/;"	n	file:
dmp	src/linear_approx.cpp	/^namespace dmp{$/;"	n	file:
dmp	src/radial_approx.cpp	/^namespace dmp{$/;"	n	file:
dt	script/sample.py	/^    dt = 1.0                $/;"	v
dt	script/sample.py	/^    dt = 1.0$/;"	v
evalAt	src/fourier_approx.cpp	/^double FourierApprox::evalAt(double x)$/;"	f	class:dmp::FourierApprox
evalAt	src/linear_approx.cpp	/^double LinearApprox::evalAt(double x)$/;"	f	class:dmp::LinearApprox
evalAt	src/radial_approx.cpp	/^double RadialApprox::evalAt(double x)$/;"	f	class:dmp::RadialApprox
features	include/dmp/fourier_approx.h	/^	double *features;  \/\/Storage for a set of features$/;"	m	class:dmp::FourierApprox
features	include/dmp/radial_approx.h	/^	double *features;  \/\/Storage for a set of features$/;"	m	class:dmp::RadialApprox
generatePlan	src/dmp.cpp	/^void generatePlan(const vector<DMPData> &dmp_list,$/;"	f	namespace:dmp
getNumBases	include/dmp/function_approx.h	/^	int getNumBases(){return n_bases;}$/;"	f	class:dmp::FunctionApprox
getWeights	include/dmp/function_approx.h	/^	std::vector<double> getWeights(){return weights;}$/;"	f	class:dmp::FunctionApprox
goal	script/sample.py	/^    goal = [8.0,7.0]         #Plan to a different goal than demo$/;"	v
goal_thresh	script/sample.py	/^    goal_thresh = [0.2,0.2]$/;"	v
integrate_iter	script/sample.py	/^    integrate_iter = 5       #dt is rather large, so this is > 1  $/;"	v
learnFromDemo	src/dmp.cpp	/^void learnFromDemo(const DMPTraj &demo,$/;"	f	namespace:dmp
leastSquaresWeights	src/fourier_approx.cpp	/^void FourierApprox::leastSquaresWeights(double *X, double *Y, int n_pts)$/;"	f	class:dmp::FourierApprox
leastSquaresWeights	src/linear_approx.cpp	/^void LinearApprox::leastSquaresWeights(double *X, double *Y, int n_pts){};$/;"	f	class:dmp::LinearApprox
leastSquaresWeights	src/radial_approx.cpp	/^void RadialApprox::leastSquaresWeights(double *X, double *Y, int n_pts)$/;"	f	class:dmp::RadialApprox
lfdCallback	nodes/dmp_server.cpp	/^bool lfdCallback(LearnDMPFromDemo::Request  &req,$/;"	f
main	nodes/dmp_server.cpp	/^int main(int argc, char **argv)$/;"	f
makeLFDRequest	script/sample.py	/^def makeLFDRequest(dims, traj, dt, K_gain, $/;"	f
makePlanRequest	script/sample.py	/^def makePlanRequest(x_0, x_dot_0, t_0, goal, goal_thresh, $/;"	f
makeSetActiveRequest	script/sample.py	/^def makeSetActiveRequest(dmp_list):$/;"	f
n_bases	include/dmp/function_approx.h	/^	int n_bases;					\/\/The number of bases in the approximator$/;"	m	class:dmp::FunctionApprox
num_bases	script/sample.py	/^    num_bases = 4          $/;"	v
plan	script/sample.py	/^    plan = makePlanRequest(x_0, x_dot_0, t_0, goal, goal_thresh, $/;"	v
planCallback	nodes/dmp_server.cpp	/^bool planCallback(GetDMPPlan::Request  &req,$/;"	f
points	include/dmp/linear_approx.h	/^        std::vector<pt_pair> points;$/;"	m	class:dmp::LinearApprox
pseudoinverse	src/fourier_approx.cpp	/^MatrixXd FourierApprox::pseudoinverse(MatrixXd mat){$/;"	f	class:dmp::FourierApprox
pseudoinverse	src/radial_approx.cpp	/^MatrixXd RadialApprox::pseudoinverse(MatrixXd mat){$/;"	f	class:dmp::RadialApprox
pt_pair	include/dmp/linear_approx.h	/^typedef std::pair<double, double> pt_pair;$/;"	t	namespace:dmp
resp	script/sample.py	/^    resp = makeLFDRequest(dims, traj, dt, K, D, num_bases)$/;"	v
seg_length	script/sample.py	/^    seg_length = -1          #Plan until convergence to goal$/;"	v
sort_pt_pair	src/linear_approx.cpp	/^bool sort_pt_pair(const pt_pair& left, const pt_pair& right)$/;"	f	namespace:dmp
t_0	script/sample.py	/^    t_0 = 0                $/;"	v
tau	script/sample.py	/^    tau = 2 * resp.tau       #Desired plan should take twice as long as demo$/;"	v
traj	script/sample.py	/^    traj = [[1.0,1.0],[2.0,2.0],[3.0,4.0],[6.0,8.0]]$/;"	v
traj_x	script/sample.py	/^    traj_x =[1.0,2,0,3,0,6,0]$/;"	v
traj_y	script/sample.py	/^    traj_y =[1.0,2,0,4,0,8,0]$/;"	v
weights	include/dmp/function_approx.h	/^	std::vector<double> weights;	\/\/The weight vector$/;"	m	class:dmp::FunctionApprox
widths	include/dmp/radial_approx.h	/^	double *widths;    \/\/Widths of RBFs$/;"	m	class:dmp::RadialApprox
x_0	script/sample.py	/^    x_0 = [0.0,0.0]          #Plan starting at a different point than demo $/;"	v
x_dot_0	script/sample.py	/^    x_dot_0 = [0.0,0.0]   $/;"	v
~FourierApprox	src/fourier_approx.cpp	/^FourierApprox::~FourierApprox()$/;"	f	class:dmp::FourierApprox
~FunctionApprox	include/dmp/function_approx.h	/^	virtual ~FunctionApprox(){};$/;"	f	class:dmp::FunctionApprox
~LinearApprox	src/linear_approx.cpp	/^LinearApprox::~LinearApprox(){};$/;"	f	class:dmp::LinearApprox
~RadialApprox	src/radial_approx.cpp	/^RadialApprox::~RadialApprox()$/;"	f	class:dmp::RadialApprox
